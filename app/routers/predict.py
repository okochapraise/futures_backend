from fastapi import APIRouter, Query
from fastapi.responses import JSONResponse
from app.services.binance import fetch_ohlcv
from app.services.news import fetch_crypto_news
from app.utils.email_utils import send_email
from app.utils.db import insert_signal  # ‚úÖ NEW: import DB logging
import os
import traceback
from app.utils.db import get_signals 

router = APIRouter()

@router.get("/")
async def get_prediction(pair: str = Query(..., description="Trading pair e.g., SOLUSDT")):
    try:
        df = await fetch_ohlcv(pair)

        # ‚úÖ Handle invalid/unknown pairs gracefully
        if df is None or df.empty:
            return JSONResponse(status_code=404, content={
                "error": f"No historical data available for pair '{pair}'. It may be invalid or too new."
            })

        candles = df[["timestamp", "open", "high", "low", "close", "volume"]].tail(5).to_dict(orient="records")

        latest = df.iloc[-1]
        rsi = latest["rsi"]
        macd = latest["macd"]
        macd_signal = latest["macd_signal"]
        entry_price = latest["close"]

        reason = []
        confidence = 50
        action = "Hold"
        stop_loss = None
        take_profit = None
        macd_score = 0
        sentiment_score = 0

        # üîç Rule-based logic
        if rsi < 30 and macd > macd_signal:
            action = "Buy"
            confidence = 80
            macd_score = 80
            reason.append("RSI < 30 (oversold) and MACD > Signal")
        elif rsi > 70 and macd < macd_signal:
            action = "Sell"
            confidence = 80
            macd_score = 80
            reason.append("RSI > 70 (overbought) and MACD < Signal")
        elif macd > macd_signal:
            action = "Buy"
            confidence = 65
            macd_score = 65
            reason.append("MACD crossover detected (Bullish)")
        elif macd < macd_signal:
            action = "Sell"
            confidence = 65
            macd_score = 65
            reason.append("MACD crossover detected (Bearish)")
        else:
            reason.append("No strong signal detected")

        # üìà SL / TP logic
        if action == "Buy":
            stop_loss = round(entry_price * 0.98, 3)
            take_profit = round(entry_price * 1.04, 3)
        elif action == "Sell":
            stop_loss = round(entry_price * 1.02, 3)
            take_profit = round(entry_price * 0.96, 3)

        # üì∞ News sentiment
        news_sentiment = await fetch_crypto_news(pair)
        reason.append(f"News sentiment: {news_sentiment}")

        if action == "Sell" and "positive" in news_sentiment.lower():
            sentiment_score = -15
            confidence += sentiment_score
            reason.append("Positive sentiment weakens sell signal")
            if confidence < 60:
                action = "Hold"
        elif action == "Buy" and "negative" in news_sentiment.lower():
            sentiment_score = -15
            confidence += sentiment_score
            reason.append("Negative sentiment weakens buy signal")
            if confidence < 60:
                action = "Hold"

        # üìß Send email if confidence is high enough
        if confidence >= 70:
            email_body = f"""
üö® Signal Alert for {pair} üö®

üîπ Action: {action.upper()}
üîπ Confidence Score: {confidence}%
üîπ Market Order: {action} at ${entry_price:.2f}
üîπ Take Profit: ${take_profit if take_profit else 'N/A'}
üîπ Stop Loss: ${stop_loss if stop_loss else 'N/A'}

üìä Reasons:
{chr(10).join(f"‚Ä¢ {r}" for r in reason)}

üìÖ Timestamp: {candles[-1]["timestamp"]}

This is an automated trading signal generated by your AI-based strategy bot.
"""
            await send_email(
                subject=f"üìà {action} signal for {pair}",
                body=email_body,
                to=os.getenv("ALERT_EMAIL")
            )

            # ‚úÖ Log high-confidence signal to database
            insert_signal({
                "pair": pair,
                "signal": action,
                "confidence": confidence,
                "entry_price": entry_price,
                "stop_loss": stop_loss,
                "take_profit": take_profit,
                "timestamp": str(candles[-1]["timestamp"]), 
                "reasons": "\n".join(reason)
            })

    except Exception as e:
        return JSONResponse(status_code=400, content={
            "error": str(e),
            "details": traceback.format_exc()
        })

    return {
        "pair": pair,
        "signal": action,
        "confidence": confidence,
        "entry_price": entry_price,
        "stop_loss": stop_loss,
        "take_profit": take_profit,
        "order_type": "Market",
        "reason": reason,
        "recent_candles": candles,
        "score_breakdown": {
            "macd_score": macd_score,
            "sentiment_score": sentiment_score,
            "net_score": confidence
        }
    }

@router.get("/history")
def get_signal_history(page: int = Query(1, ge=1, description="Page number")):
    try:
        data = get_signals(page=page, page_size=10)
        return {
            "page": page,
            "page_size": 10,
            "results": data,
            "count": len(data)
        }
    except Exception as e:
        return JSONResponse(status_code=500, content={
            "error": str(e)
        })
